Did you successfully set the segment base addresses and sizes to ensure all the memory addresses in the "addresses" list are valid? If yes, explain how you achieved this. If not, describe the challenges you encountered.
Yes. First, I knew that we were segmenting into 3 sections. The first section (Heap) had to have started at the address 0. Splitting the address up equally into 3 sections, gave each segment 5 addresses. To ensure no overlapping, the size had to be +1 of the last address in a segment. So the last address in the 5 address block for Heap was 32768. Add 1 to that to get the size 32769. Repeat this for the 2nd 5 address block. Starting with 1073741824, we can see that once again we have a size of 32768 between the starting address in the Code segment. Add 1 to ensure no overlapping and move onto the last segment, Stack. The 5 address in the segment stack have a size of 32767. Add 1 to this to get a size of 32768. This all ensures that there isn't overlapping between addresses and that the size is large enough to account for this. Once I calculated the Base and Size values for each segment (and many many issues with cmake), I compiled the "Lab7" aka Lab5. I was able to get "[OK] Total segment memory size fits within physical memory size."

Why is it important to properly configure memory segments in an application?
It's useful to properly allocate resources so the system knows exactly which segments to access. They also help the computer to access different segments at the same time. Finally, properly configuring memory segments help map virtual addresses to physical addresses.

How can understanding memory segmentation help prevent segmentation faults and improve memory management?
You want to ensure that there are no overlapping memory addresses. This will also allow memory to be used more efficiently. Having specific memory segments allocated for certain usage helps improve memory management and prevent segmentation faults. 